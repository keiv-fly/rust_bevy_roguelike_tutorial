<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Map creation and adding walls - Roguelike tutorial with Rust and Bevy</title>


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded "><a href="chapter01.html"><strong aria-hidden="true">1.</strong> Setting Up</a></li><li class="chapter-item expanded "><a href="chapter02.html"><strong aria-hidden="true">2.</strong> Drawing the "@" symbol and moving around</a></li><li class="chapter-item expanded "><a href="chapter03.html" class="active"><strong aria-hidden="true">3.</strong> Map creation and adding walls</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Roguelike tutorial with Rust and Bevy</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/keiv-fly/rust_bevy_roguelike_tutorial/tree/main/tutorial" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                        <a href="https://github.com/keiv-fly/rust_bevy_roguelike_tutorial/edit/main/tutorial/src/chapter03.md" title="Suggest an edit" aria-label="Suggest an edit">
                            <i id="git-edit-button" class="fa fa-edit"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="map-creation-and-adding-walls"><a class="header" href="#map-creation-and-adding-walls">Map creation and adding walls</a></h1>
<h2 id="moving-player-creation-into-separate-files"><a class="header" href="#moving-player-creation-into-separate-files">Moving player creation into separate files</a></h2>
<p>Let's move the following code into <code>maps.rs</code>:</p>
<pre><code class="language-rust  noplayground">use bevy::prelude::Component;

#[derive(Component)]
pub struct TilePosition {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}
</code></pre>
<p>The fields are set to <code>pub</code> in order to get access to them from outside files.</p>
<p>And now we move the following code to <code>player.rs</code>:</p>
<pre><code class="language-rust  noplayground">use bevy::prelude::{
    Commands, Component, Handle, SpriteSheetBundle, TextureAtlas, TextureAtlasSprite, Transform,
    Vec3,
};

use crate::map;

#[derive(Component)]
pub struct Player;

pub fn spawn_player(mut commands: Commands, texture_atlas_handle: Handle&lt;TextureAtlas&gt;) {
    commands
        .spawn()
        .insert(Player)
        .insert_bundle(SpriteSheetBundle {
            texture_atlas: texture_atlas_handle,
            transform: Transform::from_translation(Vec3::new(0., 0., 0.)),
            sprite: TextureAtlasSprite::new(94),
            ..Default::default()
        })
        .insert(map::TilePosition { x: 0, y: 0, z: 0 });
}
</code></pre>
<p>both of the files should have <code>mod</code> lines in <code>main.rs</code>:</p>
<pre><code class="language-rust  noplayground">mod map;
mod player;
</code></pre>
<p>Now the game compiles with <code>cargo run</code> and we can see the same picture as before with &quot;@&quot; sign in the middle.</p>
<h2 id="adding-map-resource"><a class="header" href="#adding-map-resource">Adding map resource</a></h2>
<p>To add the map resource we change the <code>map.rs</code> file in the following way:</p>
<pre><code class="language-rust  noplayground">use std::collections::HashMap;

use bevy::prelude::{Component, Entity};

const NUM_LAYERS: i32 = 5;

#[derive(Component)]
pub struct TilePosition {
    pub x: i32,
    pub y: i32,
    pub z: i32,
}

pub struct Map {
    pub forward: Vec&lt;Vec&lt;Vec&lt;Option&lt;Entity&gt;&gt;&gt;&gt;,
    pub backward: HashMap&lt;Entity, TilePosition&gt;,
    pub width: usize,
    pub height: usize,
    pub num_layers: usize,
    pub zero_pos: TilePosition,
}
impl Map {
    pub fn new(width: usize, height: usize, zero_pos_x: i32, zero_pos_y: i32) -&gt; Map {
        let num_layers = NUM_LAYERS as usize;
        Self {
            forward: vec![vec![vec![None; width]; height]; num_layers],
            backward: HashMap::new(),
            width: width,
            height: height,
            num_layers: num_layers,
            zero_pos: TilePosition {
                x: zero_pos_x,
                y: zero_pos_y,
                z: 0,
            },
        }
    }
}
impl std::fmt::Display for Map {
    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
        write!(f, &quot;&lt;Map width={} height={}&gt;&quot;, self.width, self.height)
    }
}
</code></pre>
<p><code>Map</code> struct has the following parts:</p>
<ul>
<li>The <code>forward</code> field of the struct is the map itself where we can find entities in a three-dimensional vector. Two dimensions are the positions on the screen and the third dimension is the layer</li>
<li>The <code>backward</code> field is where we can identify where a specific entity is on the map. </li>
<li><code>width</code>, <code>height</code> and <code>num_layers</code> are also stored there. </li>
<li>The constructor <code>new</code> creates empty <code>forward</code> and <code>backward</code> fields and sets the <code>width</code>, <code>height</code> and the <code>num_layers</code> of the <code>Map</code>.</li>
</ul>
<p>We also added the implementation of the <code>std::fmt::Display</code> trait for debugging. Currently it does not print much but we will add more to it later.</p>
<p>In the <code>main.rs</code> file we created the map in <code>setup()</code>:</p>
<pre><code class="language-rust  noplayground">    //Create the map
    let mut my_map = map::Map::new(
        usize::try_from(WINDOW_COLUMNS).ok().unwrap(),
        usize::try_from(WINDOW_ROWS).ok().unwrap(),
        WINDOW_COLUMNS / 2,
        WINDOW_ROWS / 2,
    );
</code></pre>
<p>And then added it to resources so we could use it in systems later. The lines are inserted at the end of <code>setup()</code> function:</p>
<pre><code class="language-rust  noplayground">    // Insert map as a resourse
    commands.insert_resource(map);
</code></pre>
<p>Now the <code>setup()</code> function looks like this:</p>
<pre><code class="language-rust  noplayground">fn setup(
    mut commands: Commands,
    asset_server: Res&lt;AssetServer&gt;,
    mut texture_atlases: ResMut&lt;Assets&lt;TextureAtlas&gt;&gt;,
) {
    // Setup the sprite sheet
    let texture_handle = asset_server.load(&quot;DejaVu Sans Mono22.png&quot;);
    let texture_atlas =
        TextureAtlas::from_grid(texture_handle, Vec2::new(TILE_WIDTH, TILE_HEIGHT), 31, 7);
    let texture_atlas_handle = texture_atlases.add(texture_atlas);

    // Add a 2D Camera
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());

    //Create map
    let mut my_map = map::Map::new(
        usize::try_from(WINDOW_COLUMNS).ok().unwrap(),
        usize::try_from(WINDOW_ROWS).ok().unwrap(),
        WINDOW_COLUMNS / 2,
        WINDOW_ROWS / 2,
    );

    // Spawn the player
    player::spawn_player(&amp;mut commands, texture_atlas_handle);

    // Insert map as a resourse
    commands.insert_resource(map);
}

</code></pre>
<p>Now move the code with constants to <code>contants.rs</code> file and add some more constants there. So now the new file contains the following:</p>
<pre><code class="language-rust  noplayground">pub const TILE_WIDTH: f32 = 22.;
pub const TILE_HEIGHT: f32 = 36.;
pub const WINDOW_COLUMNS: i32 = 80;
pub const WINDOW_ROWS: i32 = 30;
</code></pre>
<p>We add the constants to <code>main.rs</code> like this:</p>
<pre><code class="language-rust  noplayground">use constants::{TILE_HEIGHT, TILE_WIDTH, WINDOW_COLUMNS, WINDOW_ROWS};
</code></pre>
<p>Similar in <code>map.rs</code>:</p>
<pre><code class="language-rust  noplayground">use crate::constants::{TILE_HEIGHT, TILE_WIDTH};
</code></pre>
<p>The code should compile, but nothing new is happening.</p>
<h2 id="adding-walls"><a class="header" href="#adding-walls">Adding walls</a></h2>
<p>Let's implement some methods for our <code>TilePosition</code> struct.</p>
<pre><code class="language-rust  noplayground">impl TilePosition {
    pub fn new(x: i32, y: i32, z: i32) -&gt; TilePosition {
        Self { x: x, y: y, z: z }
    }
    pub fn to_vec3(&amp;self) -&gt; Vec3 {
        Vec3::new(
            self.x as f32 * TILE_WIDTH,
            self.y as f32 * TILE_HEIGHT,
            self.z as f32,
        )
    }
}
</code></pre>
<p>The <code>new</code> method is a constructor that allows us to write coordinates without explicitly stating the name of the coordinate.</p>
<p>The <code>to_vec3</code> will be used later for sprite creation. Now our <code>tile_position_to_transform()</code> function is moved to <code>map.rs</code> and looks very simple:</p>
<pre><code class="language-rust  noplayground">pub fn tile_position_to_transform(tile_position: TilePosition, mut transform: Mut&lt;Transform&gt;) {
    transform.translation = tile_position.to_vec3();
}
</code></pre>
<p>An empty struct is added to the code as a Component to identify walls:</p>
<pre><code class="language-rust  noplayground">#[derive(Component)]
pub struct Wall;
</code></pre>
<p>Now we add another function to <code>impl Map</code>:</p>
<pre><code class="language-rust  noplayground">    fn spawn_a_wall(
        &amp;mut self,
        commands: &amp;mut Commands,
        texture_atlas_handle: &amp;Handle&lt;TextureAtlas&gt;,
        position: TilePosition,
    ) {
        let id = commands
            .spawn()
            .insert(Wall)
            .insert_bundle(SpriteSheetBundle {
                texture_atlas: texture_atlas_handle.clone(),
                transform: Transform::from_translation(position.to_vec3()),
                sprite: TextureAtlasSprite::new(186), // Full fill
                ..Default::default()
            })
            .insert(position.clone())
            .id();
        let corrected_x = position.x + self.zero_pos.x;
        let corrected_y = position.y + self.zero_pos.y;
        let corrected_z = position.z + self.zero_pos.z;
        self.forward[usize::try_from(corrected_x).ok().unwrap()]
            [usize::try_from(corrected_y).ok().unwrap()]
            [usize::try_from(corrected_z).ok().unwrap()] = Some(id.clone());
        self.backward.insert(id.clone(), position.clone());
    }
</code></pre>
<p>This function will allow us to insert a wall from the <code>setup()</code> function in <code>main.rs</code>. Creation of the entity, adding a <code>Wall</code> component and inserting the sprite is very similar to the player code. Only now we choose number <code>186</code> from the texture, because we represent the wall with a filled rectangular. After adding <code>TilePosition</code> component we also return the <code>Entity</code> struct so that we could save the entity to the map. Then the position is converted from world coordinates that can be negative to map coordinates that are positive.</p>
<p>With <code>self.forward</code> we then add the entity to the 3d vector.</p>
<p>In addition we also add the entity and the position to <code>self.backward</code> so we could find the position in the array based on <code>id</code>.</p>
<p>The next function is the function that will be called from <code>setup()</code> in <code>main.rs</code> to add three walls:</p>
<pre><code class="language-rust  noplayground">    pub fn spawn_walls(
        &amp;mut self,
        commands: &amp;mut Commands,
        texture_atlas_handle: &amp;Handle&lt;TextureAtlas&gt;,
    ) {
        self.spawn_a_wall(commands, texture_atlas_handle, TilePosition::new(-1, 2, 0));
        self.spawn_a_wall(commands, texture_atlas_handle, TilePosition::new(0, 2, 0));
        self.spawn_a_wall(commands, texture_atlas_handle, TilePosition::new(1, 2, 0));
    }
</code></pre>
<p>So in the function we just repeat the call to <code>spawn_a_wall</code> function with different coordinates.</p>
<p>and also add the following line in <code>setup()</code> function in <code>main.rs</code> to spawn the walls:</p>
<pre><code class="language-rust  noplayground">    my_map.spawn_walls(&amp;mut commands, &amp;texture_atlas_handle);
</code></pre>
<pre><code class="language-rust  noplayground">fn setup(
    mut commands: Commands,
    asset_server: Res&lt;AssetServer&gt;,
    mut texture_atlases: ResMut&lt;Assets&lt;TextureAtlas&gt;&gt;,
) {
    // Setup the sprite sheet
    let texture_handle = asset_server.load(&quot;DejaVu Sans Mono22.png&quot;);
    let texture_atlas =
        TextureAtlas::from_grid(texture_handle, Vec2::new(TILE_WIDTH, TILE_HEIGHT), 31, 7);
    let texture_atlas_handle = texture_atlases.add(texture_atlas);

    // Add a 2D Camera
    commands.spawn_bundle(OrthographicCameraBundle::new_2d());

    //Create the map
    let mut my_map = map::Map::new(
        usize::try_from(WINDOW_COLUMNS).ok().unwrap(),
        usize::try_from(WINDOW_ROWS).ok().unwrap(),
        WINDOW_COLUMNS / 2,
        WINDOW_ROWS / 2,
    );
    my_map.spawn_walls(&amp;mut commands, &amp;texture_atlas_handle);

    // Spawn the player
    player::spawn_player(&amp;mut commands, texture_atlas_handle);

    // Insert the map as a resourse
    commands.insert_resource(my_map);
}
</code></pre>
<p>Now it compiles and we can see the walls. If we move to the walls they do not prevent us from moving to their tiles. This is the next chapter.
<img src="img/Roguelike03-01.png" alt="Roguelike03-01" /></p>
<p>The final code could be found here:
<a href="https://github.com/keiv-fly/rust_bevy_roguelike_tutorial/tree/main/code/chapter03">Chapter03 code</a></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="chapter02.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="chapter02.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->


    </body>
</html>
